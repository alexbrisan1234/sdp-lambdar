#! /usr/bin/python3
from src.code.communication.comms import Serial_Comm
from enum import Enum
from src.code.control.motor import *
from src.code.control.pid import PID
import time


__DEBUG__ = False

class Arnold:
    # Arnold's to main sensory inputs
    ultra_data = None
    infra_data = None

    class Mode(Enum):
        FOLLOW = 1      # Default operation mode. Robot will blindly follow the carrot
        OBSTACLE = 2    # Activates on signal loss or path blockage. Robot switches to wall following
        WAIT = 3        # Halt actuation and wait for a usable

    def __init__(self, cs=400, dur=5000, maxsp = 1000):
        self.motors = ArnoldMotors({'frontLeft':'A','frontRight':'B','rearLeft':'C','rearRight':'D'}, cs);
        self.acting_mode = self.Mode.FOLLOW
        # Catch error for incorrect serial port
        try:
            self.ser = Serial_Comm(oport="/dev/ttyACM0")
        except FileNotFoundError:
            self.ser = Serial_Comm(oport="/dev/ttyACM1")

        self.pid_tracking = PID(P=2.0, I=0.0, D=0.0)
        self.pid_avoidance = PID(P=2.0, I=0.0, D=8.0)

        self.constant_speed = cs
        self.left_speed = cs
        self.right_speed = cs
        self.duration = dur
        self.obstacle_position = -1
        self.obstacle_distance = 0
        self.pid_output = 0.00

        self.max_speed = maxsp
        self.no_signal = 0xFFFFFFFF
        self.ultra_data_is_old = False
        self.threshold = 20

        self.left_side_distance = self.no_signal
        self.right_side_distance = self.no_signal


    def live(self):
        'Main loop of Arnold. Updates model and perform motions'
        while True:
            try:
                new_data = self.ser.read_message()

                if new_data[0] != None:
                    self.ultra_data = new_data[0]

                if new_data[1] != None:
                    self.infra_data = new_data[1]

                if __DEBUG__ :
                    if self.ultra_data != None: print('Ultrasonic: ', self.ultra_data)
                    if self.infra_data != None: print('Infrared: ', self.infra_data)



                # If the data from the ultrasonics is old then switch modes
                if self.ultra_data != None and int(round(time.time() * 1000)) - self.ultra_data.timestamp > 1000:
                    self.acting_mode = self.Mode.OBSTACLE
                    if __DEBUG__: print('Entering Obstacle Avoidance Mode')
                else:
                    self.acting_mode = self.Mode.FOLLOW

                # Update motion based on current

                if self.ultra_data != None and self.infra_data != None:
                    self.actuate()
                elif __DEBUG__:
                    print('No data received')

            except KeyboardInterrupt:
                self.motors.stop()
                print('Aborting Robot Operation')
                break

    # Determine if we are actually getting a distance from an obstacle or if it is noise
    def isInRange(self, dist1, dist2):
        return abs(dist1-dist2)<self.threshold

    # right - 1, 0 , left -  2, 4
    def actuate(self):
        'Logic for selecting an actuation strategy and activating motors'
        if self.acting_mode == self.Mode.FOLLOW:
            # get the pid output to tune the speed and direction
            self.pid_output = self.pid_tracking.update_tracking(self.ultra_data.get_left(),
                                                       self.ultra_data.get_right(),
                                                       self.ultra_data.timestamp)
            self.motors.set_turning_rate(-self.pid_output)


        elif self.acting_mode == self.Mode.OBSTACLE:
            print("ir", self.infra_data)
            if(self.isInRange(self.infra_data.get_infrared_sensor_data(0), self.infra_data.get_infrared_sensor_data(1))):
                self.right_side_distance =  abs(self.infra_data.get_infrared_sensor_data(0) - self.infra_data.get_infrared_sensor_data(1))
                print("right side in range")
            else:
                self.right_side_distance = self.no_signal
                print("right side not in range")

            if(self.isInRange(self.infra_data.get_infrared_sensor_data(2), self.infra_data.get_infrared_sensor_data(4))):
                self.left_side_distance =  abs(self.infra_data.get_infrared_sensor_data(2) - self.infra_data.get_infrared_sensor_data(4))
                print("left side in range")
            else:
                self.left_side_distance = self.no_signal
                print("left side not in range")

            if self.right_side_distance!=self.no_signal or self.left_side_distance!=self.no_signal:

                self.obstacle_distance = min(self.infra_data.get_infrared_sensor_data(0), self.infra_data.get_infrared_sensor_data(4))

                print(self.obstacle_distance, "obstacle distance")
                if self.obstacle_distance == self.infra_data.get_infrared_sensor_data(0):
                    self.obstacle_position = 1
                    print("obstacle on the right")
                else:
                    self.obstacle_position = 0
                    print("obstacle on the left")
                self.pid_output = self.pid_avoidance.update_collision_avoidance(self.obstacle_distance, self.infra_data.timestamp)

                self.motors.set_turning_rate(-self.pid_output)
            # if there is no signal from both sides, turn to avoid the previously recorded corner
            else:
                print("turning!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
                if(self.obstacle_position == 1):
                    sign = -1
                else:
                    sign = 1
                self.motors.set_turning_rate(self.constant_speed*sign)

        elif self.acting_mode == self.Mode.WAIT:
            if __DEBUG__:
                print('Wait Mode')

    def update_state(self):
        if self.ultra_data != None and int(round(time.time() * 1000)) - self.ultra_data.timestamp > 1000:
            self.acting_mode = self.Mode.OBSTACLE
            if __DEBUG__:
                print('Entering Obstacle Avoidance Mode')
        else:
            self.acting_mode = self.Mode.FOLLOW

if __name__ == '__main__':
    arn = Arnold()
    arn.live()
