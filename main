#! /usr/bin/python3
from src.code.communication.comms import Serial_Comm
from src.code.communication.mqtt import MqttHelper
from enum import Enum
from src.code.control.motor import ArnoldMotors
from src.code.control.pid import PID
import time

__DEBUG__ = True
__OUT_OF_RANGE_MESSAGE__ = 'OR'

class Arnold:
    # Arnold's to main sensory inputs
    ultra_data = None
    infra_data = None

    class Mode(Enum):
        FOLLOW = 1      # Default operation mode. Robot will blindly follow the carrot
        OBSTACLE = 2    # Activates on signal loss or path blockage. Robot switches to wall following
        WAIT = 3        # Halt actuation and wait for a usable

    def __init__(self, cs=200, dur=5000, maxsp = 1000):
        self.motors = ArnoldMotors({'frontLeft':'A','frontRight':'B','rearLeft':'C','rearRight':'D'}, cs)
        self.acting_mode = self.Mode.WAIT
        # Catch error for incorrect serial port


        self.ser = Serial_Comm()

        self.pid_tracking = PID(P=2.0, I=0.0, D=0.0)
        self.pid_avoidance = PID(P=1.0, I=0.0, D=0.0, SP = 0)

        self.constant_speed = cs
        self.left_speed = cs
        self.right_speed = cs
        self.duration = dur
        self.obstacle_position = -1 
        self.obstacle_distance = 0
        self.pid_output = 0.00

        self.max_speed = maxsp
        self.no_signal = 0xFFFFFFFF
        self.ultra_data_is_old = False

        self.mqttHelper = MqttHelper()

        self.__sentNotification = False

        try:
            self.mqttHelper.connect()
            self.mqttHelper.listen()
        except:
            if __DEBUG__:
                print('Could not connect to MQTT Helper')


    def live(self):
        'Main loop of Arnold. Updates model and perform motions'
        while True:
            try:
                if __DEBUG__:print('Started Read')
                new_data = self.ser.read_message()
                if __DEBUG__:print('Finished')

                if new_data[0] != None:
                    self.ultra_data = new_data[0]

                if new_data[1] != None:
                    self.infra_data = new_data[1]

                if __DEBUG__ :
                    if self.ultra_data != None: print('Ultrasonic: ', self.ultra_data)
                    if self.infra_data != None: print('Infrared: ', self.infra_data)

                #TODO: work out priority of mode and when to switch
                # If the data from the ultrasonics is old then switch modes
                if self.ultra_data != None and int(round(time.time() * 1000)) - self.ultra_data.timestamp > 1000:
                    self.sendOutOfRangeNotification()
                    self.acting_mode = self.Mode.OBSTACLE
                    if __DEBUG__: print('Entering Obstacle Avoidance Mode')
                elif self.ultra_data != None:
                    if __DEBUG__:
                        print("We can now send notifications again")
                    self.__sentNotification = False
                    self.acting_mode = self.Mode.FOLLOW
                else:
                    self.acting_mode = self.Mode.WAIT

                # Update motion based on current
                # if we have data for any of the modes, we can actuate on them
                if self.ultra_data != None or self.infra_data != None:
                    self.actuate()
                elif __DEBUG__:
                    print('No data received')

            except KeyboardInterrupt:
                self.motors.stop()
                print('Aborting Robot Operation')
                break


    def actuate(self):
        'Logic for selecting an actuation strategy and activating motors'
        '''
        if self.acting_mode == self.Mode.FOLLOW:
            # get the pid output to tune the speed and direction
            self.motors.set_parameters(
                self.get_following_output()
            )

        elif self.acting_mode == self.Mode.OBSTACLE:
            self.motors.set_turning_rate(
                self.get_avoidance_output()
            )
        '''

        following_output = self.get_following_output()
        avoidance_output = self.get_avoidance_output()

        sign = lambda x : 1 if x > 0 else -1 if x < 0 else 0

        if sign(following_output) == sign(avoidance_output):
            self.motors.set_turning_rate(max(following_output, avoidance_output))
        else:
            self.motors.set_turning_rate(avoidance_output)

        if self.acting_mode == self.Mode.WAIT:
            if __DEBUG__:
                print('Wait Mode')

    def get_following_output(self):
        pid_output = self.pid_tracking.update_tracking(self.ultra_data.get_left(),
                                                       self.ultra_data.get_right(),
                                                       self.ultra_data.timestamp)
            #self.motors.set_turning_rate(-self.pid_output)

        dist = (self.ultra_data.get_left() + self.ultra_data.get_right()) / 2
        spd = 0
        if dist < 31500:
            spd = 0
        elif dist > 33500:
            spd = self.constant_speed
        else:
            spd = self.constant_speed * (dist - 31500) / 2000
        
        # self.motors.set_parameters(spd, -self.pid_output)
        return pid_output

    def get_avoidance_output(self):
        leftReading = self.infra_data.get_infrared_sensor_data(1)
            rightReading = self.infra_data.get_infrared_sensor_data(2)
            middleReading = self.infra_data.get_infrared_sensor_data(0)

            #self.obstacle_distance = min(self.infra_data.get_infrared_sensor_data(0), self.infra_data.get_infrared_sensor_data(2))    
            #if self.obstacle_distance == self.infra_data.get_infrared_sensor_data(0):
            #    self.obstacle_position = 1
            #else:
            #    self.obstacle_position = 0
            leftDistance = min(leftReading, 70)
            rightDistance = min(rightReading, 70)
            middleDistance = min(middleReading, 70)

            frontCoeff = 0
            if middleDistance!=0 and middleDistance<70:
                #frontCoeff = 60000/(middleDistance*middleDistance - middleDistance)
                '''Will be 2000 (turning on the spot when middleDistance==20. Change 20 to change
                    the threshold. Coeff will be halved every 10cm. Change 2 to change the ratio
                    (e.g. divide by 3 or 4 every 10cm). Change 10 to halve more/less often.'''
                frontCoeff = 2000 * 2**((20 - middleDistance)/10)
                if leftDistance<rightDistance:
                    frontCoeff = -1*frontCoeff

                # frontCoeff = (1+((leftDistance-rightDistance)/((abs(leftDistance-rightDistance))+1))) * 4000 / middleDistance -100
            
            leftCoeff = 2000 * 2**((20 - leftDistance)/10)
            rightCoeff = 2000 * 2**((20 - rightDistance)/10)
            
            if __DEBUG__:
                print("Left distance is : {}".format(leftDistance))
                print("Right distance is : {}".format(rightDistance))

            pid_output = self.pid_avoidance.update_collision_avoidance(-leftCoeff + rightCoeff + frontCoeff, self.infra_data.timestamp)

            # self.motors.set_turning_rate(self.pid_output)

            return pid_output

    def update_state(self):
        if self.ultra_data != None and int(round(time.time() * 1000)) - self.ultra_data.timestamp > 1000:
            # self.acting_mode = self.Mode.OBSTACLE
            if __DEBUG__:
                print('Entering Obstacle Avoidance Mode')
        else:
            self.acting_mode = self.Mode.FOLLOW

    def sendOutOfRangeNotification(self):
        if not self.__sentNotification:
            self.mqttHelper.send_message(__OUT_OF_RANGE_MESSAGE__)
            self.__sentNotification = True

    def __del__(self):
        self.mqttHelper.stop_listening()

if __name__ == '__main__':
    arn = Arnold()
    arn.live()
