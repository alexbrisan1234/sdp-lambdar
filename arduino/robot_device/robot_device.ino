#define DEBUG 1

// Tracking settings
const int kTrigAllPin = 5;  // All receivers are connected to this pin
const int kLeftEchoPin = 6;  // needs to be between 2 and 7 (inclusive)
const int kRightEchoPin = 7;  // needs to be between 2 and 7 (inclusive)
const uint32_t kReceiverTimeout = 110000;

// IR Settings
int ir_receiver_pins[] = {A1, A2, A3, A4, A5};
uint32_t ir_data[] = {0, 0, 0, 0, 0};

const String iID = "I";

// Ultrasonic Settings
struct TimeData {
    uint32_t leftUD;
    uint32_t rightUD;
};

struct TimeData uTimeData;

// This ID identifies ultrasonic data
const String uID = "U";

// Masks for echo pins
const uint8_t kLeft = (1 << kLeftEchoPin);
const uint8_t kRight = (1 << kRightEchoPin);
const uint8_t kBoth = kLeft | kRight;

// Radio settings
const uint32_t kRadioDelay = 10000;  // Time of radio communication in microseconds
const String kRadioRequestCode = "$$$";

// Comm Settings
// Code for no signal received
const uint32_t kNoSig = 0xFFFFFFFF;
// Code identifies beginning of message
const String kOpenMsg = "<";
// Code identifies end of message
const String kCloseMsg = ">";
const String kLineSep = "|";

/*
 * Used to activate the receivers
 */
void activateUltrasonic(int trigPin);
/*
 * Sends radio signal to user's device to cause it to emit an ultrasonic pulse.
 */
void requestSignal();
/*
 * Waits for signal to be received on both receivers and returns the time since
 * `startTime` it took in the `timeLeft` and `timeRight` pointers. If no signal
 * is received, the respective output is set to 0xFFFFFFFF (2^32 - 1).
 */
void measureTimes(uint32_t startTime, uint32_t* timeLeft, uint32_t* timeRight);
/*
 * Uses port manipulation to read all echo pins (specified by the `mask`)
 * extremely fast (~0.1 us).
 * (`PIND` is a byte containing values of pins 0-7.)
 */
uint8_t getEcho(uint8_t mask) {return PIND & mask;}

/*
 * Converst a voltage to a distance
 */
uint32_t convertVoltageToDistance(int voltage);

/*
 * Listens for IR signal
 */
void listenForIR();

/*
 * Sends IR signal
 */
void sendIRData();

/*
 * Sends data generated by sensors over serial
 */

void sendUltraData();

void setup() 
{
  // Radio setup
  pinMode(8,OUTPUT); // switch off the radio
  digitalWrite(8,HIGH);
  pinMode(4,OUTPUT); // switch on the radio
  digitalWrite(4,LOW); // ensure the radio is not sleeping
  Serial.begin(9600);

  // Tracking pins setup
  pinMode(kTrigAllPin, OUTPUT);
  digitalWrite(kTrigAllPin, LOW);
  pinMode(kLeftEchoPin, INPUT);
  pinMode(kRightEchoPin, INPUT);
  
  sendIRData();
}

void loop() 
{
  activateUltrasonic(kTrigAllPin);
  delayMicroseconds(600);
  uint32_t t0 = micros();
  // Both echo pins should be high now
  if (getEcho(kBoth) != kBoth) {
    Serial.print("ERROR: Unexpected echo state");
    Serial.print(kLineSep);
  }
  requestSignal();

  // Now we have about 20 ms to do stuff

  measureTimes(t0, &(uTimeData.leftUD), &(uTimeData.rightUD));

  // Now we have uTimeData.leftUD and uTimeData.rightUD. We can send them to EV3 or store them
  // in global variables and send in the next iteration. We can also do other
  // stuff here.

  // Send data over serial to the ev3 brick
  digitalWrite(8,LOW);
  sendUltraData();
  listenForIR();
  sendIRData();
  delay(1);
  digitalWrite(8,HIGH);
  
  delay(100);  // TODO: should probably be removed or reduced
}

void requestSignal() {
  Serial.print(kRadioRequestCode);
  Serial.print(kLineSep);
  Serial.flush();
}

// Ultrasonic Functions
void measureTimes(uint32_t startTime, uint32_t* timeLeft, uint32_t* timeRight)
{
  uint8_t echo = getEcho(kBoth);
  // Both echo pins should still be high
  if (echo != kBoth) {
    Serial.print("ERROR: Listening too late");
    Serial.print(kLineSep);
  }

  *timeLeft = 0xFFFFFFFF;   // Max number
  *timeRight = 0xFFFFFFFF;  // Max number
  // Wait for echo pins to go low and note times
  while (echo != 0x00) {
    echo = getEcho(kBoth);
    if ((*timeLeft == 0xFFFFFFFF) && ((echo & kLeft) == 0))
      *timeLeft = micros() - startTime;
    if ((*timeRight == 0xFFFFFFFF) && ((echo & kRight) == 0))
      *timeRight = micros() - startTime;
  }

  // Check for timeouts
  if (*timeLeft > kReceiverTimeout) *timeLeft = 0xFFFFFFFF;
  if (*timeRight > kReceiverTimeout) *timeRight = 0xFFFFFFFF;

  // Check radio delay
  if (*timeLeft < kRadioDelay) {
    Serial.print("ERROR: Radio delay too high. timeLeft=");
    Serial.print(*timeLeft);
    Serial.print(kLineSep);
    *timeLeft = 0xFFFFFFFF;
  }
  if (*timeRight < kRadioDelay) {
    Serial.print("ERROR: Radio delay too high. timeRight=");
    Serial.print(*timeRight);
    Serial.print(kLineSep);
    *timeRight = 0xFFFFFFFF;
  }

  // Adjust for radio delay
  if (*timeLeft != 0xFFFFFFFF)
    *timeLeft -= kRadioDelay;
  if (*timeRight!= 0xFFFFFFFF)
    *timeRight -= kRadioDelay;
}

void activateUltrasonic(int trigPin)
{
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
}

/* IR Functions */
uint32_t convertVoltageToDistance(int voltage){
  return (voltage != 0) ? (uint32_t)(63438.5*pow(voltage, -1.15)+0.5) : kNoSig;
}

void listenForIR(){
  for(int i=0;i<5;i++){
    ir_data[i] = convertVoltageToDistance(analogRead(ir_receiver_pins[i]));
  }
}

void sendUltraData() {
  Serial.print(kOpenMsg);
  Serial.print(uID);
  Serial.print(uTimeData.leftUD);
  Serial.print(" ");
  Serial.print(uTimeData.rightUD);
  Serial.print(kCloseMsg);
  Serial.print(kLineSep);
  Serial.flush();
}

void sendIRData(){
  Serial.print(kOpenMsg);
  Serial.print(iID);
  for(int i = 0; i < 4; ++i){
    Serial.print(ir_data[i]);
    Serial.print(" ");
  }
  Serial.print(ir_data[4]);
  Serial.print(kCloseMsg);
  Serial.print(kLineSep);
  Serial.flush();
}
